
# 🔄 동기 vs 비동기 / 블로킹 vs 논블로킹

---

## ✅ 동기 vs 비동기

| 구분 | 동기 (Synchronous) | 비동기 (Asynchronous) |
|------|--------------------|------------------------|
| 처리 방식 | 작업이 끝날 때까지 기다림 | 작업을 요청하고 바로 다음 작업 수행 |
| 흐름 제어 | 순차적 | 병렬 가능 |
| 예시 | 함수 호출 후 반환값 기다림 | 콜백 함수, 이벤트 리스너 |

### 📌 예시

```csharp
// 동기
int result = DoWork(); // 끝날 때까지 기다림

// 비동기
DoWorkAsync().ContinueWith(task => {
    Console.WriteLine("작업 완료");
});
```

---

## ✅ 블로킹 vs 논블로킹

| 구분 | 블로킹 (Blocking) | 논블로킹 (Non-Blocking) |
|------|-------------------|-------------------------|
| 자원 점유 | 작업 끝날 때까지 점유 | 자원 점유하지 않음 |
| 대기 | 호출한 곳에서 대기 | 대기하지 않고 바로 반환 |
---

## ✅ 개념 관계

- **동기 & 블로킹**: 가장 기본적인 방식 (끝날 때까지 기다림)
- **비동기 & 논블로킹**: 이벤트 기반 프로그래밍에 적합
- 혼합 가능: 예) 동기 + 논블로킹 방식도 존재

### 예시에 대한 코드
```csharp
Socket socket = ...;

// 논블로킹 설정
socket.Blocking = false;

// 동기적으로 호출하지만, 데이터가 없으면 예외 발생하고 바로 반환
try {
    int count = socket.Receive(buffer);  // 동기 호출
} catch (SocketException e) {
    // 데이터가 없으면 기다리지 않고 바로 예외 발생 (논블로킹 동작)
}

// 이 코드는 "동기 방식"으로 Receive를 호출하지만,
// 소켓을 "논블로킹 모드"로 설정했기 때문에
// 읽을 데이터가 없으면 기다리지 않고 SocketException을 발생시키며 바로 빠져나감
//
// 즉, "동기 + 논블로킹" 방식임

---

## ✅ 핵심 요약

> - **동기 vs 비동기**: 흐름 제어 방식
> - **블로킹 vs 논블로킹**: 자원 점유/대기 여부
> - 실무에서는 네트워크 I/O, 멀티스레딩 등과 연관 깊음
