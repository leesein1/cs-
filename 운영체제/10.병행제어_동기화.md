# 🔒 병행 제어 & 동기화

## ✅ 병행 제어 & 동기화란?

✅ 1. 왜 병행 제어 & 동기화가 필요한가?
> 현대 프로그램은 성능을 위해 멀티 스레드 또는 멀티 프로세스를 사용합니다.
> 여러 스레드가 **공유 자원(변수, 파일, UI 등)**에 동시에 접근하면 예기치 않은 오류나 충돌이 발생할 수 있습니다.
> 예를 들어, A 스레드가 데이터를 수정하고 있는 도중 B 스레드가 그 값을 읽으면 일관성이 깨질 수 있습니다.

✅ 2. 병행 제어 (Concurrency Control)
> 여러 스레드/프로세스가 동시에 실행되더라도,
> 공유 자원에 대한 접근을 안전하게 조정하는 기술을 말합니다.
> 즉, **"겹치거나 충돌하지 않게 순서를 조율하는 것"**입니다.
> 예: 은행 계좌 잔고를 동시에 입출금하면 잔액이 꼬일 수 있음 → 병행 제어가 필요함

✅ 3. 동기화 (Synchronization)
> 병행 제어를 구현하는 기술/방법입니다.
> 작업들 간의 "타이밍을 맞추는 것", 즉 **"순서를 강제로 정해주는 것"**입니다.
> 주요 기술로는 Mutex, Semaphore, Lock, Monitor, volatile, invoke 등이 있습니다.
> 예: 스레드 A가 데이터를 수정하는 동안 스레드 B는 대기하도록 만들기 → 동기화


## 요약
| 항목    | 의미                               | 역할                     |
| ----- | -------------------------------- | ---------------------- |
| 병행 제어 | 동시에 실행되는 스레드들 간 **충돌 방지와 순서 제어** | 충돌 자체를 막는 전략           |
| 동기화   | 병행 제어를 위해 **스레드 실행 시점을 맞추는 기술**  | 충돌을 피하도록 실행 순서나 대기를 설정 |

---

## ✅ 교착 상태 (Deadlock)

- 둘 이상의 프로세스가 **서로 자원을 기다리며** 무한 대기하는 상황
- 발생 조건 (4가지 모두 충족 시 발생):
  1. **상호 배제** (Mutual Exclusion) – 자원을 하나의 프로세스만 사용할 수 있음
  2. **점유 대기** (Hold and Wait) – 자원을 가진 채 다른 자원을 기다림
  3. **비선점** (No Preemption) – 자원을 강제로 뺏을 수 없음
  4. **환형 대기** (Circular Wait) – 각 프로세스가 다음 프로세스가 가진 자원을 기다림

### 코드 예시
```csharp
object lock1 = new object();
object lock2 = new object();

Thread t1 = new Thread(() =>
{
    lock (lock1) // 🔐 lock1 먼저 확보
    {
        Thread.Sleep(100); // 일부러 지연
        lock (lock2) // 🔒 lock2도 확보 시도
        {
            Console.WriteLine("T1 done");
        }
    }
});

Thread t2 = new Thread(() =>
{
    lock (lock2) // 🔐 lock2 먼저 확보
    {
        Thread.Sleep(100); // 일부러 지연
        lock (lock1) // 🔒 lock1도 확보 시도
        {
            Console.WriteLine("T2 done");
        }
    }
});

```
> 1. T1이 먼저 lock1을 잡음
> 2. 동시에 T2가 lock2를 잡음
> 3.둘 다 Sleep(100)으로 일부러 딜레이를 줘서
> ( T1은 lock2를 기다리고, T2는 lock1을 기다림 )
> 4. 서로 자원을 내놓지 않고 기다림 → 교착 상태 발생

### 4가지 만족 표

| 번호                                | 조건                       | 현재 예제에서의 상황                                       |
| --------------------------------- | ------------------------ | ------------------------------------------------- |
| **① 상호 배제**<br>(Mutual Exclusion) | 한 자원은 한 스레드만 사용할 수 있어야 함 | `lock1`, `lock2`는 한 번에 하나의 스레드만 사용할 수 있음          |
| **② 점유 대기**<br>(Hold and Wait)    | 자원을 점유한 채 다른 자원을 기다림     | T1은 `lock1`을 점유한 상태에서 `lock2`를 기다리고 있음 / T2도 마찬가지 |
| **③ 비선점**<br>(No Preemption)      | 자원을 강제로 뺏을 수 없음          | C#의 `lock`은 자원을 다른 스레드가 **강제로 뺏을 수 없음**           |
| **④ 환형 대기**<br>(Circular Wait)    | 프로세스들이 원형으로 자원을 기다림      | T1 → T2 → T1 로 자원을 순환하며 기다리는 구조                   |

---

## ✅ 세마포어 / 뮤텍스

> 병렬 제어를 하기 위한 세마포어와 뮤텍스 즉, 스레드 간 충돌 방지를 위한 장치

| 항목    | 세마포어 (Semaphore)                        | 뮤텍스 (Mutex)                        |
| ----- | --------------------------------------- | ---------------------------------- |
| 자원 수  | 여러 개 가능 (n개)                            | 단 하나만 가능 (1개)                      |
| 소유권   | 없음 (누구나 해제 가능)                          | 있음 (잠근 스레드만 해제 가능)                 |
| 용도    | **개수 제어** (리소스 수 제한)                    | **상호 배제** (단독 접근 보장)               |
| 사용 예  | 프린터 3대 → 최대 3개 접근 허용                    | 단일 파일 → 오직 1개 스레드만 접근              |


- **세마포어**는 공유 자원의 접근 개수를 제한할 때 사용하며, 이 경우 예시로 든 2개의 스레드 충돌은 사용자가 관리해야함
  예: 프린터가 2대 있을 경우, 2개까지만 접근 허용

- **뮤텍스**는 하나의 스레드만 자원에 접근하도록 보장  
  예: 하나의 파일을 동시에 두 스레드가 수정하지 못하게 할 때

