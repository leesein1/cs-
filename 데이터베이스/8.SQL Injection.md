# 🧾 SQL Injection 완전 정복

> SQL Injection(인젝션)은 **사용자 입력이 SQL 문장 안에 그대로 포함될
> 때** 발생하는 취약점.\
> 방어의 핵심은 **"SQL과 값을 절대 문자열로 합치지 않는 것"**이다.

------------------------------------------------------------------------

# ✅ 1. SQL Injection이 발생하는 이유

SQL 문자열을 이렇게 **직접 조립**할 때 취약해진다:

``` sql
SELECT * FROM tb_user WHERE userId = ' " + userInput + " '
```

사용자가 `1' OR 1=1 --` 입력하면:

``` sql
SELECT * FROM tb_user WHERE userId = '1' OR 1=1 --'
```

➡ **조건을 무단 우회**하여 모든 데이터가 노출됨\
➡ Injection 공격 성공

------------------------------------------------------------------------

# ✅ 2. 안전한 패턴의 핵심 --- 파라미터 바인딩

SQL Injection을 막는 핵심 원리는 **SQL과 값을 완전히 분리**하는 것.

모든 언어/프레임워크에서 공통 개념:

  기술          안전한 방식              원리
  ------------- ------------------------ -----------------------------------
  C#            AddWithValue             값과 SQL을 분리해 DB에 전달
  Java          PreparedStatement        `?` + setXxx() 형태
  MyBatis       `#{}`                    내부적으로 PreparedStatement 변환
  DB 프로시저   sp_executesql 파라미터   SQL 텍스트와 값을 분리

------------------------------------------------------------------------

# ✅ 3. C#에서의 SQL Injection 방어 --- AddWithValue()

``` csharp
cmd.CommandText = "SELECT * FROM tb_test WHERE userId = @userId";
cmd.Parameters.AddWithValue("@userId", userInput);
```

### 📌 특징

-   SQL은 그대로 전송됨
-   값은 별도의 파라미터로 전달
-   값 안에 공격 문자열이 있어도 **SQL 문장에 삽입되지 않음**

➡ **인젝션 완전 차단**

------------------------------------------------------------------------

# ✅ 4. Java에서의 방어 --- PreparedStatement

``` java
String sql = "SELECT * FROM tb_test WHERE userId = ?";
PreparedStatement pstmt = conn.prepareStatement(sql);
pstmt.setString(1, userInput);
```

### 📌 특징

-   `?` 위치에 값만 바인딩
-   SQL 텍스트는 절대 변하지 않음

➡ C#의 AddWithValue와 **1:1 동일한 보안 원리**

------------------------------------------------------------------------

# ✅ 5. MyBatis에서의 방어 --- `#{}` vs 위험한 `${}`

## ✔ 안전: `#{}`

``` xml
WHERE userId = #{userId}
```

➡ 파라미터 바인딩(PreparedStatement 방식) → **안전**

## ❌ 위험: `${}`

``` xml
WHERE userId = ${userId}
```

사용자 입력이 그대로 SQL에 삽입됨:

``` sql
WHERE userId = 1 OR 1=1
```

➡ **문자열 조립 → 인젝션 100% 발생**

------------------------------------------------------------------------

# ✅ 6. DB 내부에서의 동적 SQL 위험

아래처럼 **문자열 조립**을 하면 다시 위험해진다:

``` sql
SET @sql = 'SELECT * FROM tb_test WHERE userId = ' + @userId;
EXEC(@sql);
```

➡ DB 안에서도 인젝션 가능

## ✔ 안전한 방법 (sp_executesql + 파라미터)

``` sql
SET @sql = N'SELECT * FROM tb_test WHERE userId = @userId';
EXEC sp_executesql @sql,
     N'@userId NVARCHAR(50)',
     @userId = @userId;
```

➡ DB 내부에서도 PreparedStatement 방식 구현\
➡ **완전 방어**

------------------------------------------------------------------------

# ✅ 7. Spring Controller → Service → DAO 구조에서 인젝션 여부가 결정되는 지점

  레이어                 인젝션 영향?        설명
  ---------------------- ------------------- -----------------------------
  Controller(Map 받기)   ❌ 없음             단순 입력 수집
  ServiceImpl            ❌ 없음             sqlId 설정/로직 처리
  CommonMapper           ❌ 없음             MyBatis 호출
  **MyBatis XML**        **✔ 여기서 결정**   `#{}` → 안전 / `${}` → 취약

### 📌 핵심

> **인젝션은 Mapper.xml에서 `#{}` 사용 여부로 완벽하게 결정된다.**

------------------------------------------------------------------------

# 🧠 요약

### ✔ 인젝션 발생 조건

-   문자열로 SQL을 조립할 때\
    (`"SELECT... " + input` / `${}` / DB 동적 SQL 문자열 조립)

### ✔ 인젝션 방어 조건

-   SQL과 값을 **분리해서 전달**할 때\
    (AddWithValue / PreparedStatement / MyBatis `#{}` / sp_executesql)

------------------------------------------------------------------------

# ⭐ 한 줄 정리

> **SQL Injection은 "SQL 문자열 조립"에서만 발생한다.\
> 파라미터 바인딩을 쓰면 어떤 언어에서도 100% 차단된다.**
