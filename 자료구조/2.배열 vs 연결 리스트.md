# 2. 배열 vs 연결 리스트


<summary>📘 핵심 비교</summary>

| 항목 | 배열 (Array) | 연결 리스트 (Linked List) |
|------|---------------|-----------------------------|
| 저장 방식 | 연속된 메모리 공간 | 노드마다 데이터 + 포인터 |
| 접근 속도 | 빠름 (O(1)) | 느림 (O(n)) |
| 삽입/삭제 | 느림 (중간에서 O(n)) | 빠름 (중간에서 O(1), 위치만 알면) |
| 메모리 효율 | 공간 낭비 가능 (미리 할당) | 동적으로 할당해서 효율적 |
| 구현 난이도 | 간단함 | 포인터 관리로 복잡함 |
| 사용 예시 | 고정된 크기, 빠른 접근이 필요한 경우 | 크기 변화가 많고 삽입/삭제가 잦은 경우 |

---

## ✅ 배열 (Array)

- 연속된 메모리에 데이터를 저장
- 인덱스로 바로 접근 가능 → `arr[3]`
- 삽입/삭제 시 모든 요소를 옮겨야 해서 느림

```C#
int[] arr = new int[5];
arr[0] = 10;  // arr[0,1,2,3,4] 중 0번에 10 저장

int x = arr[0];  // arr의 첫 번째 값인 10을 x에 저장
Console.WriteLine(x);  // 출력: 10

```
```C#
저장 결과 : arr = [10, 0, 0, 0, 0]
출력 : 10
```

---

<br>

## ✅ 연결 리스트 (Linked List)

- 각 노드가 다음 노드를 가리키는 구조
- 중간 삽입/삭제가 쉬움 (주소만 바꾸면 됨)
- 하지만 인덱스 접근이 느림 → 순차 탐색 필요

> 연결 리스트 예시 (단일 연결 리스트)

```C#
class Node {
    public int data;
    public Node next;
}

Node head = new Node();           // 첫 번째 노드
head.data = 10;

head.next = new Node();          // 두 번째 노드
head.next.data = 20;

head.next.next = new Node();     // 세 번째 노드
head.next.next.data = 30;


Node current = head; // 첫번째 노드부터 시작

while (current != null)
{
    Console.WriteLine(current.data);
    current = current.next;
}

```

```C#
저장 결과 : [10] → [20] → [30] → null
             ↑                ↑
           head              tail

📌 head: 연결 리스트의 시작점 (첫 번째 노드)
📌 tail: 연결 리스트의 끝점 (마지막 노드, next == null)

출력
10
20
30

```

## 🔗 그 외 연결 리스트의 종류

단일 연결 리스트말고도 연결 리스트는 노드 간의 연결 방식에 따라 여러 가지로 나뉜다.

---

| 종류 | 구조 | 특징 |
|------|------|------|
| **단일 연결 리스트**<br>(Singly Linked List) | `A → B → C → null` | 한 방향(`next`)으로만 이동 가능 |
| **원형 연결 리스트**<br>(Circular Linked List) | `A → B → C → A` | 마지막 노드가 첫 노드(`head`)를 가리킴 |
| **이중 연결 리스트**<br>(Doubly Linked List) | `A ⇄ B ⇄ C` | 양방향 이동 가능 (`next`, `prev`) |
| **이중 원형 연결 리스트**<br>(Doubly Circular Linked List) | `A ⇄ B ⇄ C ⇄ A` | 양방향 + 원형 구조 (처음과 끝이 연결됨) |

> 단일 연결 리스트

```C#
[10] → [20] → [30] → null
     ↑             ↑
    head          tail
```
> 원형 연결 리스트

```C#
[10] → [20] → [30]
  ↑               ↓
  └────── head ←──┘
```

> 이중 연결 리스트

```C#
null ← [10] ⇄ [20] ⇄ [30] → null
       head               tail
```

> 이중 원형 연결 리스트

```C#
[10] ⇄ [20] ⇄ [30]
 ↑               ↓
 └────── head ←──┘
```

## 그럼 언제 사용할까??
| 상황                       | 추천 리스트       |
| ------------------------ | ------------ |
| 데이터 삽입/삭제가 많고 한 방향 탐색이면  | 단일 연결 리스트    |
| 순환 구조 필요 (ex: 게임 턴 last player -> first) | 원형 연결 리스트    |
| 양방향 이동 필요 (이전 노드 탐색 등)   | 이중 연결 리스트    |
| 캐시 구조처럼 양방향+순환 구조 필요     | 이중 원형 연결 리스트 |

> 🔍 참고: 포인터를 직접 다뤄야 하므로 이중/원형 구조는 **구현이 더 복잡하지만**, 상황에 따라 성능이나 구조 측면에서 이점을 가질 수 있음.

<br>

---

# 📌 최종 요약: 배열 vs 연결 리스트

### 🔹 배열 (Array)
- **인덱스로 직접 접근 가능** → 빠른 조회 성능 (`O(1)`)
- 하지만 **크기 고정**, **중간 삽입/삭제 시 느림** (`O(n)`)
- 예: `arr[3]` 으로 바로 접근 가능하지만, 중간 요소 삭제 시 모두 한 칸씩 당겨야 함

---

### 🔹 연결 리스트 (Linked List)
- 각 노드가 포인터로 연결됨 → **중간 삽입/삭제는 빠름** (`O(1)`, 단, **직전 노드를 알고 있는 경우에 한함**)
- 하지만 **인덱스 접근 불가**, **항상 앞에서부터 순차 탐색** 필요 (`O(n)`)
- 예: `head → ... → target` 까지 하나씩 따라가야 접근 가능

---

### ✅ 선택 기준 요약

| 상황                          | 추천 자료구조     |
|-----------------------------|------------------|
| 특정 위치 자주 접근 필요        | 배열 (Array)     |
| 중간 삽입/삭제가 자주 발생      | 연결 리스트 (Linked List) |
