# 🧠 해시 테이블 (Hash Table)

> 키(key)를 해시 함수(hash function)에 넣어 \*\*인덱스(index)\*\*를 계산한 뒤,
> 그 위치에 값을 저장하는 **배열 기반의 자료구조**

---

## ✅ 개요

| 항목     | 설명                                                           |
| ------ | ------------------------------------------------------------ |
| 정의     | Key → Hash 함수 → Index → 배열에 저장                               |
| 시간복잡도  | 평균 O(1), 최악 O(n) [`체이닝 많이 사용 시`]                                |
| 내부 구조  | 배열 기반 + 충돌 처리용 보조 구조                                         |
| 언어별 구현 | C#: `Dictionary`, Java: `HashMap`, Python: `dict`, JS: `Map` |

---

## ✅ 해시 함수(Hash Function)

* Key(문자열 등)를 → 숫자(Index)로 변환하여 메모리에 저장
* 이상적인 해시 함수는:

  * 연산이 빠름
  * 충돌이 적음
  * 해시값이 고르게 분포됨 ( 체이닝 및 테이블 빈 값 없는 경우 )

예시:

```csharp
string key = "apple";
int hash = key.GetHashCode() % table.Length;
결과 : int hash 에는 문자열 apple 의 해시값이 저장 됨
```


## ✅ 왜 `% table.Length`가 필요한가?

해시 테이블은 내부적으로 **배열**을 사용하므로,  
**해시 함수 결과값(hash code)**를 배열 인덱스 범위 안으로 제한해야 함.

### 🔸 문제 상황

- `GetHashCode()`는 `int` 범위 내의 아주 큰 수 또는 음수를 반환할 수 있음
  ```csharp
  int hash = "apple".GetHashCode();  // 예: -2028131633
  ```
  > 하지만 배열이 100칸이면 인덱스는 0 ~ 99까지만 가능함 → 위 값은 배열 인덱스로 부적절 ❌

### 🔸 해결 방법
> %table.Length로 인덱스를 배열 범위 내로 제한
> Math.Abs()로 음수를 양수로 바꿔줌

```csharp
int index = Math.Abs(key.GetHashCode() % table.Length);
→ 항상 0 이상 table.Length 미만의 인덱스값 보장 ✅
```
---

## ✅ 충돌(Collision)과 처리 방법

> 서로 다른 Key가 같은 Index를 가지게 되면 → 충돌 발생

### 충돌 처리 방식:

| 방식                       | 설명                      | 장점     | 단점          |
| ------------------------ | ----------------------- | ------ | ----------- |
| 체이닝(Chaining)            | 같은 인덱스에 연결 리스트로 여러 값 저장 | 구현 쉬움  | 메모리 추가 필요   |
| 오픈 어드레싱(Open Addressing) | 빈 곳 또는 다음 칸으로 저장        | 메모리 절약 | 클러스터링(해시 테이블에 값이 한곳에 몰려, 여러번 탐색하게 되어 성능 저하) 문제 가능 |

---

## ✅ 시간복잡도

| 연산 | 평균   | 최악 (충돌 심해지면) |
| -- | ---- | ------------ |
| 생성 | O(1) | O(n)         |
| 삭제 | O(1) | O(n)         |
| 탐색 | O(1) | O(n)         |

※ 해시 함수 성능 + 테이블 크기 + 충돌 처리 방식에 따라 성능이 달라질 수 있음

---

## ✅ 실전 활용 예시

* 중복 제거 (`HashSet`)
* 빠른 탐색 (`Dictionary`)
* 빈도 수 세기 (ex: 문자열에서 가장 많이 나오는 문자)
* 코딩 테스트 대표 문제: **Two Sum**, **전화번호 목록**, **애너그램 그룹핑**

---

## ✅ 예제 (C#)

```csharp
Dictionary<string, int> map = new Dictionary<string, int>();

// 생성
map["apple"] = 3;

// 검색
Console.WriteLine(map["apple"]);  // 출력: 3

// 존재 확인
if (map.ContainsKey("banana"))
    Console.WriteLine("바나나 있음");

// 삭제
map.Remove("apple");
```

### 출력

```
3
```

---

## 잠깐 !! JSON vs 해시 테이블

| 항목    | JSON (문자열 기반)     | 해시 테이블 (자료구조)        |
| ----- | ----------------- | -------------------- |
| 구조    | Key → Value (문자열) | Key → Value (메모리 구조) |
| 저장 위치 | 파일, 문자열, 네트워크 전송용 | 메모리 (실행 중 연산용)       |
| 탐색 방식 | 문자열 파싱 후 탐색       | 해시 함수로 인덱스 바로 계산     |
| 속도    | 느림 (파싱 필요)        | 빠름 (O(1))            |
| 사용 목적 | 데이터 표현, 전송, 저장    | 실시간 탐색, 삽입, 삭제       |

> ✅ JSON도 Key로 값에 접근할 수 있지만, 내부적으로는 문자열을 파싱해야 하므로 해시 테이블처럼 빠르지 않음

---

## ✅ 면접에서 자주 나오는 질문

* 해시 테이블의 시간복잡도는 왜 O(1)인가요?
* 충돌이 생겼을 때는 어떻게 처리하나요?
* 오픈 어드레싱 방식은 어떤 문제가 생길 수 있나요?
* 해시 테이블과 이진 탐색 트리의 차이점은?
* JSON과 해시 테이블의 차이점은?

---

## ✅ 요약

> 해시 테이블은 **탐색과 생성이 매우 빠른 배열 기반의 자료구조**이며,
> **충돌 처리와 해시 함수 품질에 따라 성능이 좌우된다.**
> Key와 Value는 프로그래머가 지정하며, 해시 함수는 Key로부터 인덱스를 계산해주는 내부 계산기 역할을 한다.
