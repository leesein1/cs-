# 📊 정렬 (Sorting)

정렬이란 데이터를 일정한 순서(오름차순 또는 내림차순)로 나열하는 알고리즘입니다. 다양한 상황에 따라 효율적인 정렬 알고리즘이 다르며, 시간 복잡도와 공간 복잡도를 고려해 선택합니다.

> 📌 우리가 자주 사용하는 `sort()` 함수(JavaScript, Python 등)나 SQL의 `ORDER BY` 구문 역시 내부적으로는 이 정렬 알고리즘들을 기반으로 동작합니다. 예를 들어, Python은 Timsort, JavaScript는 브라우저마다 QuickSort 또는 MergeSort 계열 알고리즘을 사용하며, SQL 서버는 인덱스 상태나 데이터 양에 따라 Merge Sort, Heap Sort 등을 적용합니다.

이처럼 정렬 알고리즘은 단순히 구현 연습용이 아니라, 우리가 매일 사용하는 데이터 정렬의 핵심 엔진이기도 합니다.

---

## ✅ 기본 정렬 알고리즘

| 정렬 방식     | 시간 복잡도 (평균/최악) | 공간 복잡도 | 특징 | 간단한 예시 |
|--------------|------------------------|-------------|------|-------------|
| 버블 정렬    | O(n²) / O(n²)          | O(1)        | 인접한 값을 반복 비교하며 위치 교환 | `[5, 3, 1] → [3, 5, 1] → [3, 1, 5] → [1, 3, 5]` |
| 선택 정렬    | O(n²) / O(n²)          | O(1)        | 최솟값을 선택해 앞으로 이동 | `[5, 3, 1] → [1, 3, 5]` |
| 삽입 정렬    | O(n²) / O(n²)          | O(1)        | 앞에서부터 정렬된 상태로 삽입 | `[5, 3, 1] → [3, 5, 1] → [1, 3, 5]` |

---

> 실제 사용하는 `sort()` 함수들도 이러한 기본 정렬 알고리즘을 기반으로 최적화되어 있습니다.  
> 버블 정렬은 인접한 값들을 반복 비교하며 큰 값을 뒤로 보내고,  
> 삽입 정렬은 오른쪽으로 index를 확장해가며, 현재 값을 앞쪽 정렬된 영역에 알맞은 위치로 삽입합니다.

## ✅ 고급 정렬 알고리즘

### 🔹 병합 정렬 (Merge Sort)

- **개념**: 분할 정복 방식. 배열을 계속 반으로 나눈 뒤 병합하며 정렬.
- **시간 복잡도**: O(n log n)
- **공간 복잡도**: O(n)
- **특징**: 안정 정렬, 재귀 기반, 큰 데이터 처리에 적합

```csharp
[5], [2] → [2, 5]  
[4], [1] → [1, 4]  
→ [2, 5] + [1, 4] → [1, 2, 4, 5] ← 여기서 병합(정렬된 병합)

병합 정렬은 이렇게 정렬된 두 배열을 병합하는 방식이기 때문에,  
처음부터 모든 원소를 한 번에 비교하는 것보다 훨씬 효율적이다.  
즉, 1개씩 쪼개진 배열을 병합할 때마다 정렬된 상태로 비교하므로  
**전체 비교 횟수가 줄고 시간 복잡도도 O(n log n)** 으로 최적화된다.
```

---

### 🔹 퀵 정렬 (Quick Sort)

- **개념**: **기준값(Pivot)**을 하나 정하고,  
  그보다 **작은 값은 왼쪽**, **큰 값은 오른쪽**으로 보내면서 배열을 나눔.  
  이 과정을 **재귀적으로 반복하며 정렬**함.

- **시간 복잡도**: 평균 O(n log n), 최악 O(n²)  
- **공간 복잡도**: O(log n) (재귀 호출 깊이)  
- **특징**: 불안정 정렬 (같은 값의 순서 보장 X), 매우 빠름

---

#### 예시: `[5, 3, 7, 1, 4]`

1. **피벗 = 5**  
   → 5보다 작은 값: `[3, 1, 4]`, 큰 값: `[7]`  
   → 나누기 결과: `[3, 1, 4] + [5] + [7]`

2. 왼쪽 `[3, 1, 4]`에 대해 다시 퀵 정렬  
   → 피벗 = 3  
   → 나누기: `[1] + [3] + [4]`

3. 병합하면: `[1, 3, 4] + [5] + [7]` → `[1, 3, 4, 5, 7]`

---

#### 📌 핵심

- 피벗을 기준으로 **왼쪽, 오른쪽 나누기 → 재귀 호출**
- 실제 정렬은 나누는 과정에서 자연스럽게 됨
- 빠르지만, 피벗을 잘못 고르면 O(n²) 나올 수 있음 (ex: 정렬된 배열에 퀵정렬 쓰면 비효율적)

---

#### 💡 비유

> 정렬하려는 숫자 무더기에서 **기준 하나 뽑고**,  
> “이거보다 작은 애 여기!”, “큰 애 저기!” 하면서 **줄 나눠서 정렬**하는 느낌

---

### 🔹 힙 정렬 (Heap Sort)

- **개념**: 배열을 **완전 이진 트리 형태의 '힙(Heap)' 구조**로 만들어 정렬하는 방식.  
  보통은 **최대 힙(Max Heap)**을 사용하여 가장 큰 값을 하나씩 꺼내 정렬된 위치로 보냄.

- **시간 복잡도**: O(n log n)  
- **공간 복잡도**: O(1) (추가 배열 사용 없이 제자리 정렬)  
- **특징**: 불안정 정렬 (같은 값의 순서 보장 X), 추가 메모리 거의 없음

---

#### 예시: `[4, 10, 3, 5, 1]`

```tree
1. 제일 큰 숫자가 맨 위(루트)에 오도록 힙 구조로 바꾼다.  
처음 배열 : [4, 10, 3, 5, 1]  
→ 바꾼 결과 : [10, 5, 3, 4, 1]  
→ 맨 뒤 숫자 10은 제일 크니까 정렬 완료!

        10
       /  \
      5    3
     / \
    4   1
```

```tree2
2. 10을 맨 뒤로 보낸 다음 → 맨 뒤에 있던 1을 루트로 올린다  
→ [1, 5, 3, 4, 10]  
→ 다시 힙 구조로 정리 → [5, 4, 3, 1, 10]  
→ 10은 이미 정렬 완료된 상태니까 제외!

        5
       / \
      4   3
     /
    1
```

```tree3
3. 5를 맨 뒤로 보낸다 → 1이 다시 루트로 올라감 → [1, 4, 3, 5, 10]  
→ 힙 구조로 정리 → [4, 1, 3, 5, 10]  
→ 정렬된 값 : [5, 10]

        4
       / \
      1   3

이하 반복 진행...

→ 최종 정렬 결과 : [1, 3, 4, 5, 10]
```

---

#### 📌 핵심

- 힙은 **부모 ≥ 자식**인 완전 이진 트리 구조 (최대 힙 기준)
- 매 단계마다 **최댓값을 꺼내 배열 뒤로 보냄**
- 정렬은 배열 내에서 이뤄지므로 **추가 공간 사용 거의 없음**

---

#### 💡 비유

> 마치 "가장 큰 돌을 하나씩 꺼내 맨 뒤에 놓는 작업"을  
> **완전 이진 트리 규칙에 따라 반복**하는 느낌

## ✅ 정렬 알고리즘 비교 요약

| 알고리즘   | 평균 시간복잡도 | 공간복잡도 | 안정성   | 특징                      |
|------------|------------------|------------|----------|---------------------------|
| 버블 정렬  | O(n²)            | O(1)       | ✅ 안정정렬 | 구현 쉬움, 성능 낮음      |
| 선택 정렬  | O(n²)            | O(1)       | ❌ 불안정 | 단순하지만 느림           |
| 삽입 정렬  | O(n²)            | O(1)       | ✅ 안정정렬 | 거의 정렬된 자료에 효율적 |
| 병합 정렬  | O(n log n)       | O(n)       | ✅ 안정정렬 | 분할 정복, 안정적         |
| 퀵 정렬    | O(n log n)       | O(log n)   | ❌ 불안정 | 빠름, 분할 정복 기반      |
| 힙 정렬    | O(n log n)       | O(1)       | ❌ 불안정 | 추가 공간 적음            |

---

> 📌 **안정 정렬이란?** 동일한 값을 가진 원소들의 순서가 정렬 후에도 유지되는 정렬을 의미합니다.
