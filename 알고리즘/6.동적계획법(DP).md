# 🧮 동적 계획법 (Dynamic Programming, DP)

> **동적 계획법(DP)**은  
> 복잡한 문제를 **작은 하위 문제로 나누고**, 그 결과를 **저장(Memoization)** 하여  
> **중복 계산 없이 효율적으로 해결**하는 알고리즘입니다.

---

## ✅ 핵심 개념 정리

- **작은 문제의 정답을 이용해 큰 문제 해결**
- **중복되는 하위 문제를 저장(Memoization)** 하여 계산 낭비 방지
- 일반적으로 **재귀 + 저장 방식(Top-down)** 혹은 **반복문으로 쌓아가는 방식(Bottom-up)** 사용
- 대표 조건: **최적 부분 구조**, **중복 부분 문제**

---

## 🧠 일상생활 예시: 피보나치 수열

> 0, 1, 1, 2, 3, 5, 8, 13, ...  
> `f(n) = f(n-1) + f(n-2)` 라고 정의될 때,  
> `f(50)`을 구하면?

- 단순 재귀로는 **중복 호출이 많아 매우 비효율적**
- 이미 계산한 `f(n)`을 저장해두면 빠르게 해결 가능

---

## 💻 코드 예시 (C#)

### ✅ Top-down 방식 (재귀 + 메모이제이션)

```csharp
// 1. 처음이라면 일단 전부 계산 필요
int[] memo = new int[51];

int Fibonacci(int n)
{
    // 1보다 작은거라면 그냥 0 이니까 반환
    if (n <= 1){
        return n;
    } 
    // memo[n] 에 값이 저장되어 있다면 그 값을 반환
    if (memo[n] != 0) {
        return memo[n];
    }

    // 1보다 크면서 memo에 저장되어있는 값이 없다면 계산해서 저장 후 반환
    // 이때 아예 처음이라면 재귀를 통해 이전 모든 값 계산
    return memo[n] = Fibonacci(n - 1) + Fibonacci(n - 2);
}

Console.WriteLine(Fibonacci(50));
```

### ✅ Bottom-up 방식 (반복문)

```csharp
int[] dp = new int[51];
dp[0] = 0;
dp[1] = 1;

for (int i = 2; i <= 50; i++)
{
    dp[i] = dp[i - 1] + dp[i - 2];
}

Console.WriteLine(dp[50]);
```

---

## ✅ 설명

- **Top-down**은 재귀 호출을 통해 하위 문제를 풀고 결과를 저장
- **Bottom-up**은 작은 문제부터 순차적으로 쌓아올림

---

## 🎯 요약

- DP는 **중복 계산을 피하기 위해 저장**하면서 푸는 방식
- 피보나치처럼 **이전 결과가 다음 계산에 필요**할 때 유용
- Top-down (재귀), Bottom-up (반복문) 두 가지 방식 존재
- **그리디와 달리 모든 경우를 고려하며 가장 최선의 값을 보장**함