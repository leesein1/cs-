# 📘 알고리즘 개론

---

## ✅ 알고리즘이란?

- 문제를 해결하기 위한 **명확한 절차와 규칙들의 집합**.
- **입력(Input)** → **절차(Logic)** → **출력(Output)** 구조로 동작.
- 예: 정수 배열에서 최대값을 찾는 순서

```text
1. 배열의 첫 번째 값을 max로 설정
2. 나머지 값들과 비교하여 더 큰 값이 있으면 max 갱신
3. 배열 끝까지 반복 → 최종 max 출력
```

---

### 🎯 좋은 알고리즘의 조건

| 항목           | 설명 |
|----------------|------|
| ⏱️ 시간복잡도 (Time Complexity)   | 얼마나 빠르게 실행되는가?<br>입력 데이터가 커질수록 성능이 어떻게 변화하는가 |
| 💾 공간복잡도 (Space Complexity)   | 얼마나 적은 메모리를 사용하는가?<br>필요한 변수, 배열, 스택 공간 등 |
| ⚖️ 트레이드오프 (Trade-off) | 시간과 공간의 균형<br>공간을 더 써서 빠르게 하거나, 공간을 줄여서 느려질 수도 있음 |

---

### ✅ 예시

- `HashSet`  
  탐색 속도는 **O(1)** 로 빠르지만, 내부 해시 테이블 때문에 **메모리를 더 사용**함

- `이진 탐색`  
  정렬된 배열에서 탐색을 **O(log n)** 으로 수행할 수 있지만,  
  별도 공간을 거의 사용하지 않아 **공간복잡도는 낮음**

---

### ✅ 결론

> 좋은 알고리즘이란  
> **시간복잡도와 공간복잡도를 모두 고려해 문제에 적절히 최적화된 알고리즘**입니다.

---

## ✅ 시간복잡도 (Big-O)

- 입력 크기 \( n \)에 따라 알고리즘이 수행되는 **연산 횟수의 증가량**을 표현한 것
- 흔히 **O(1), O(log N), O(N), O(N log N), O(N²)** 등으로 표현


| 표기 | 의미 | 설명 | 예시 |
|------|------|------|------|
| O(1) | 상수 시간 | 입력 크기와 상관없이 한 번에 실행됨 | 배열 인덱스로 접근 `arr[0]` |
| O(log N) | 로그 시간 | 절반씩 줄여가며 찾는 방식 | 이진 탐색 (Binary Search) |
| O(N) | 선형 시간 | 전체를 한 번씩 훑는 방식 | 배열 전체 순회 |
| O(N log N) | 로그 곱 선형 | N번 반복하면서 그 안에서 로그 연산 | 병합 정렬(Merge Sort), 퀵 정렬(Quick Sort) |
| O(N²) | 제곱 시간 | 이중 반복문 → N * N 만큼 반복 | 버블 정렬(Bubble Sort), 선택 정렬 |

---

## ✅ 공간복잡도 (Space Complexity)

- **알고리즘이 실행되는 동안 사용하는 메모리 양**을 나타냄
- 입력 크기 \( n \)에 따라 얼마나 많은 추가 메모리 공간을 사용하는지를 분석

### 📌 예시

| 코드 예시 | 공간복잡도 | 설명 |
|----------|------------|------|
| `int a = 10;` | O(1) | 변수 하나만 사용 |
| `int[] arr = new int[n];` | O(n) | 배열 n개의 공간 사용 |
| `int[,] grid = new int[n,n];` | O(n²) | 2차원 배열 사용 |
| 재귀 함수 | O(n) | 호출 스택이 n층까지 쌓임 |

### ⚖️ 시간 vs 공간 트레이드오프

- **공간을 더 쓰면 속도가 빨라질 수 있음**
  - 예: 해시 테이블 → O(1) 조회
- **공간을 아끼면 시간은 느려질 수 있음**
  - 예: 매번 정렬해서 찾기 → O(n log n)

> 알고리즘 설계 시에는 **시간복잡도와 공간복잡도의 균형**을 맞추는 것이 핵심입니다.

---

## ✅ 재귀 함수 (Recursion)

- 함수가 **자기 자신을 호출**하는 방식
- 종료 조건(기저 조건)이 없으면 **무한 루프 → 스택 오버플로우** 발생

### 예시: 팩토리얼

```csharp
int Factorial(int n) {
    if (n <= 1) {
       return 1;          // 0이거나 1이면 종료
    }
    
    return n * Factorial(n - 1);   // 1이 아니면 -1 해서 1이 될때까지 무한 루프
}
```

- 재귀는 문제를 **작은 문제로 나눌 수 있을 때** 유용
- 단, 반복문으로 바꾸면 더 효율적인 경우도 많음 (→ DP로 확장 가능)

---

## 요약
> 1. 알고리즘은 문제 해결을 위한 절차로, 시간복잡도와 공간복잡도를 고려해 효율적으로 설계해야 한다.  
> 2. 대표적인 시간복잡도는 O(1), O(log N), O(N), O(N log N), O(N²) 등이 있으며, 입력 크기에 따라 성능 차이가 발생한다.  
> 3. 재귀 함수는 문제를 반복적으로 쪼갤 때 유용하지만, 종료 조건이 없으면 스택 오버플로우가 발생할 수 있다.

---